# Ядро фреймворка. #
## Жизненный цикл объектов ядра. ##

Точка входа приложения (index.php) подключает файл загрузчика boot.inc, который подключает класс приложения. Далее в точке входа могут быть переопределены  глобальные (статические) настройки приложения, после чего вызывается статический метод TApplication::Run(), который инициализирует объект приложения, передавая ему путь до точки входа, и вызывает его защищенный метод _app\_run(). При инициализации объекта приложения файл application.xml интерпретируется в несколько конфигурационных php-скриптов (в случае, если установлен флаг TApplication::CompileAppConfig и конфигурационные скрипты модифицировались ранее конфигурационного файла, либо отсутствуют). Далее в_app\_run выполняется включение конфигурационных скриптов, в результате чего формируется IOC-структура приложения, и устанавливаются свойства компонентов.
Для объекта приложения устанавливаются нижеследующие зависимости. Опционально могут быть указаны компоненты-обработчики ЧПУ, локали, интернационализации и сессий. Обязательно должен быть указан хотя бы один компонент-сервис. Дело в том, что архитектурно Jawyl представляет собой набор сервисов идентифицируемых по имени. Задача объекта приложения состоит только в том, чтобы создать IOC структуру и передать управление сервису запрошенному пользователем (клиентом). Сервис – это IOC-компонент, реализующий интерфейс IService. Сервисы объявляются в специальной секции конфигурационного файла.

После формирования структуры приложения объект приложения, используя, при необходимости, компоненты-обработчики ЧПУ, создает объект запроса (THttpRequest), который инкапсулирует все параметры http запроса, и передает управление методу Handle компонента-сервиса (TService). При этом имя компонента-сервиса может быть указано явно в параметре servicename запроса. Если имя не указано явно, то выбирается сервис, указанный по умолчанию (конфигурационный параметр default). Если сервис по умолчанию не указан, то управление последовательно передается каждому из сервисов приложения, пока  он не будет обработан одним из них.

## Структура конфигурационного файла application.xml ##


Корневым элементов конфигурационного файла является элемент application. Для данного элемента должен быть указан атрибут name. Имя приложения необходимо указывать, так как оно может быть использовано компонентами в качестве служебного значения (например, для идентификации ресурсов приложения).
Внутри элемента application может быть размещен опциональный элемент requestmap. Данный элемент служит для формирования алгоритмов разбора и формирования ЧПУ. Элемент requestmap должен содержать некоторое количество элементов route. Внутри элемента route обязательно должны присутствовать элементы request и regexp. Первый должен содержать  формат для формирования URL на основании параметров запроса, второй должен содержать регулярное выражение для разбора входящего URL. Далее в route могут быть указаны один элемент service и несколько элементов parameter. Элемент service устанавливает имя сервиса, соответствующего маршруту. Элемент parameter, который имеет обязательный атрибут name, устанавливает значение параметров запроса по умолчанию. Подробнее о работе подсистемы ЧПУ можно узнать в разделе 3.3.6 руководства.
Далее размещаются элементы component и setting. Элемент component – это объявление компонента приложения. Элемент component может быть вложенным. В этом случае дочерний компонент получает постоянную ссылку на родительский компонент, и может реализовывать механизм наследования значений свойств (прототипирования). Обязательными атрибутами компонента являются name и classname. Первый атрибут устанавливает уникальное имя компонента (для связывания), а второй имя класса компонента для инициализации. Опциональным атрибутом является атрибут membername, который служит для внедрения зависимости. В membername указать имя ioc-свойства, которому будет присвоен объявляемый компонент. Если значение атрибута указано в формате <имя компонента>.<имя свойства>, то выполнится внедрение в свойство указанного компонента. Если указано другое значение, то внедрение будет выполнено в свойство родительского компонента, либо приложения.
Элемент setting  - это инструкция, устанавливающая значение свойства компонента. Элемент setting может быть указан в контексте как любого компонента, так и всего приложения. Атрибут name элемента setting соответствует имени устанавливаемого свойства. Так как setting – это инструкция, то для каждого вхождения элемента будет выполнено соответствующее присвоение. Так, например, если свойство объявлено как массив, последовательное указание setting приведет к наполнению массива значениями. Если в качестве значения элемента setting указано имя компонента приложения, а свойство объявлено как ioc-ссылка, то производится внедрение зависимости.
Далее должен быть указан хотя бы один элемент service. Этот элемент служит для определения сервисов приложения. Логика элемента идентична логике элемента component, за некоторыми исключениями. У элемента service есть дополнительный опциональный логический атрибут default, который позволяет указать сервис в качестве сервиса по умолчанию. Компоненты, объявленные как дочерние по отношению к сервису, будут инициализированы только при обращении к этому сервису.

## Соглашения об именовании. ##

Имена классов и интерфейсов именуются в формате CamelCased. При этом в для классов используется префикс T, а для интерфейсов I.
Для публичных, в том числе и статических, членов класса принят формат именования CamelCased. Для членов класса области видимости protected следует использовать формат CamelCased со строчной первой буквой. Для именования скрытых членов класса следует использовать формат с использованием символа подчеркивания в качестве разделителя слов. При этом имя должно начинаться и заканчиваться символом подчеркивания. Константы именуются заглавными буквами с использованием знака подчеркивания в качестве разделителя. Пример правильного именования классов, интерфейсов и их членов приведен ниже:

```
interface IMyInterface {
	public function MyMethod($arg);
}

class TMyClass implements IMyInterface {
  const MY_CONST;

  private $_private_member_;
  protected $protectedMember;
  public $PublicMember;

  public function MyMethod($arg){
    $this->_private_member_ = $arg;
  }

  protected function myProtectedMethod(){
    $this->protectedMember = self::MY_CONST;
  }

  private function _my_private_method($arg){
    $this->_private_member_ = $arg;
  }
}
```